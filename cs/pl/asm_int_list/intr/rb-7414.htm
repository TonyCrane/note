<HTML>
<HEAD>
<TITLE>Int 67/AH=3Fh/CX=5145h
</TITLE>
<META NAME="Description" CONTENT="
Int 67/AH=3Fh/CX=5145h - QEMM-386 v4.23+ - INSTALLATION CHECK - 
AH = 3Fh
CX = 5145h (QE)
DX = 4D4Dh (MM)
Return: AH = 00h if installed
ES:DI - QEMM API entry point (see #03525,#03528,#03640)
Notes: if no other program has hooked INT 67, an alternate installation
check is to test for the string
QUARTERDECK EXPANDED MEMORY MANAGER 386 at offset 14h in the INT 67
handler's segment; the word at offset 12h contains the offset in
the handler's segment of the API entry point
">
<META NAME="robots" CONTENT="none">
</HEAD>
<BODY BGCOLOR="#FFD0A0">
<center>
<h2>Int 67/AH=3Fh/CX=5145h
</h2>
</center><p>
<table border=1 cellpadding=3 cellspacing=1>
<td>
<a href="rb-7413.htm">
<img src=./gif/lup.gif border=0 alt=Prev></a>
<a href="rb-7415.htm">
<img src=./gif/ldown.gif border=0 alt=Next></a>
<a href="../rbrown.htm">
<img src=./gif/lhome.gif border=0 alt=Ralf Brown Page></a>
<td><a href="int.htm">Interrups</a></td>
<td><a href="cat.htm">Categories</a></td>
<td><a href="alpha.htm">Contents</a></td>
</td></table><p>
<p><img src=./gif/rbline.gif width="100%" alt="------"><p>
<h3><font color=#C00040>QEMM-386 v4.23+ - INSTALLATION CHECK</font></h3>
<PRE>
AH = 3Fh
CX = 5145h ("QE")
DX = 4D4Dh ("MM")<br>
<p><b>Return:</b><br>AH = 00h if installed
ES:DI -> QEMM API entry point <a href="rb-0000.htm#Table0"></a>(see #03525,#03528,#03640)
</PRE>
<p><b>Notes:</b>
If no other program has hooked INT 67, an alternate installation
check is to test for the string
"QUARTERDECK EXPANDED MEMORY MANAGER 386" at offset 14h in the INT 67
handler's segment; the word at offset 12h contains the offset in
the handler's segment of the API entry point.
Although this function is still undocumented, Quarterdeck has recently
documented two alternate methods for determining the QEMM API entry
point, as well as several of the API functions.
MICEMM (Micronics Expanded Memory Manager) versions 2.0C and 4D support
the alternate QEMM installation check and entry point functions 00h,
02h, and 03h; version 4D only provides the signature string if the
commandline argument "DV" is provided.
386MAX v6.01 responds to this call, but DESQview 2.42 does not
recognize the returned entry point as providing QEMM's capabilities
because a) only functions 0Ch (different from QEMM 0Ch) and
1000h-1009h are supported,
b) status is returned as for EMS functions, not QEMM funcs
c) the protected-mode entry point returned by function 1000h
only supports functions 0Ch, 1004h, 1005h, and 100Ah.
The string check mentioned above is not supported by 386MAX
<p><b>See Also:</b>
<a href="rb-7450.htm">AX=5BF0h</a> - <a href="rb-7490.htm">AH=DDh</a> - <a href="rb-7507.htm">AX=FFA5h</a> - <a href="rb-1225.htm">INT 15/AX=11DEh<
<p><b>See Also:</b>
<a href="rb-2830.htm">INT 21/AX=4402h"QEMM"</a> - <a href="rb-2833.htm">INT 21/AX=4402h"386MAX"</a> - <a href="rb-5523.htm">INT 2F/AX=D201h/BX=5145h</a>
<PRE>
<p>
<a name=table3525></a>
(Table 03525)
Values for calling QEMM "QPI_GetStatus" function:.
AH = 00h get QEMM state<br>
<p><b>Return:</b><br>CF clear
AL = QEMM state
bit 0 set if QEMM turned OFF
bit 1 set if in "Auto" mode
</PRE>
<p><b>Note:</b>
This function is officially documented
<p><b>See Also:</b>
#03526 - #03527 - #03528 - #03640
<PRE>
<p>
<a name=table3526></a>
(Table 03526)
Values for calling QEMM "QPI_SetStatus" function:.
AH = 01h set QEMM state.
AL = new state
<p><b>bit 0 set:</b><br>Place QEMM in OFF state<br>
<p><b>Return:</b><br>CF clear if successful
CF set on error
</PRE>
<p><b>Note:</b>
This function is officially documented
<p><b>See Also:</b>
#03525
<PRE>
<p>
<a name=table3527></a>
(Table 03527)
Values for calling QEMM QPI function 02h:.
AH = 02h get ???<br>
<p><b>Return:</b><br>CF clear
AX = segment of ??? data structure
Data Structure
Offset  Size    Description
00h    DWORD   page table entry for ???
???
</PRE>
<p><b>See Also:</b>
#03528
<PRE>
<p>
<a name=table3528></a>
(Table 03528)
Values for calling QEMM "QPI_GetVersion" function:.
AH = 03h get QEMM version<br>
<p><b>Return:</b><br>CF clear
AX = BX = version in BCD
</PRE>
<p><b>Notes:</b>
This function is officially documented.  The most recent official docs
state that the version is returned in both AX and BX; older
documentation only mentions BX.
MICEMM returns AX=0001h, BX unchanged
<p><b>See Also:</b>
#03525 - #03529
<PRE>
<p>
<a name=table3529></a>
(Table 03529)
Values for calling QEMM QPI function 04h:.
AH = 04h allocate 4K page and set AUTO/ON mode<br>
<p><b>Return:</b><br>CF clear if successful
DX = page number of a 4K page
CF set if unable to allocate page
</PRE>
<p><b>Note:</b>
QEMM mode unchanged if not AUTO/OFF
<p><b>See Also:</b>
#03530
<PRE>
<p>
<a name=table3530></a>
(Table 03530)
Values for calling QEMM QPI function 05h:.
AH = 05h free 4K page and turn QEMM off.
DX = page number returned by function 04h<br>
<p><b>Return:</b><br>CF clear
</PRE>
<p><b>Note:</b>
QEMM mode unchanged if not AUTO/ON
<p><b>See Also:</b>
#03529 - #03531
<PRE>
<p>
<a name=table3531></a>
(Table 03531)
Values for calling QEMM QPI function 06h:.
AH = 06h make new mapping context???.
DX = page number of 4K page to hold page table<br>
<p><b>Return:</b><br>CF clear
</PRE>
<p><b>Note:</b>
Copies page table into given page and then sets ??? page table entry
to point at copy
<p><b>See Also:</b>
#03532 - #03533
<PRE>
<p>
<a name=table3532></a>
(Table 03532)
Values for calling QEMM QPI function 07h:.
AH = 07h get mapping context<br>
<p><b>Return:</b><br>CF clear
DX = page number of page table for current mapping context
</PRE>
<p><b>See Also:</b>
#03528 - #03531 - #03533
<PRE>
<p>
<a name=table3533></a>
(Table 03533)
Values for calling QEMM QPI function 08h:.
AH = 08h set mapping context???.
DX = linear page number of page table<br>
<p><b>Return:</b><br>CF clear
</PRE>
<p><b>See Also:</b>
#03528 - #03531 - #03532 - #03534 - #03536
<PRE>
<p>
<a name=table3534></a>
(Table 03534)
Values for calling QEMM QPI function 09h:.
AH = 09h get linear page number for page table entry.
CX = page table index<br>
<p><b>Return:</b><br>CF clear
DX = linear page number
</PRE>
<p><b>See Also:</b>
#03535
<PRE>
<p>
<a name=table3535></a>
(Table 03535)
Values for calling QEMM QPI function 0Ah:.
AH = 0Ah set linear page number for page table entry.
CX = page table index.
DX = linear page number<br>
<p><b>Return:</b><br>CF clear
</PRE>
<p><b>See Also:</b>
#03534
<PRE>
<p>
<a name=table3536></a>
(Table 03536)
Values for calling QEMM QPI function 0Bh:.
AH = 0Bh map 4K pages.
BX = number of pages.
CX = first page number (must be 0100h to allocate HMA).
DX = EMS handle (memory belonging to EMS handle will be mapped
into the address space beginning with the first page
allocated to the handle)<br>
<p><b>Return:</b><br>AH = 00h
</PRE>
<p><b>See Also:</b>
#03533 - #03537
<PRE>
<p>
<a name=table3537></a>
(Table 03537)
Values for calling QEMM QPI function 0Ch:.
AH = 0Ch get available memory<br>
<p><b>Return:</b><br>CF clear
BX = 0001h
CX = total 4K pages???
DX = number of 4K pages free
</PRE>
<p><b>See Also:</b>
#03536 - #03538
<PRE>
<p>
<a name=table3538></a>
(Table 03538)
Values for calling QEMM QPI function 0Dh:.
AH = 0Dh CRT controller I/O port trapping.
AL = mode
00h only trap on I/O ports 03C0h-03C5h, 03C7h, 03CAh-03CFh
01h trap on ports 03B4h, 03B5h, 03B8h, 03C6h, 03C8h, 03C9h,
03D4h, and 03D5h
02h only trap on I/O ports 03C6h, 03C8h, and 03C9h<br>
<p><b>Return:</b><br>CF clear
<p>
<a name=table3539></a>
(Table 03539)
Values for calling QEMM QPI function 0Eh:
AH = 0Eh set cursor virtualization callbacks
DS:BX -> FAR routine for getting hardware cursor address
ES:DX -> FAR routine for setting hardware cursor address<br>
<p><b>Return:</b><br>CF clear
</PRE>
<p><b>Note:</b>
Both callbacks are invoked with CL indicating which
CRT controller register to access (0Eh for high
byte of cursor address, 0Fh for low byte).
The DS:BX callback should return BX=cursor address;
ES:DX is called with BL or BH (depending on CL)
set to the appropriate half of the cursor's address
<PRE>
<p>
<a name=table3540></a>
(Table 03540)
Values for calling QEMM QPI function 0Fh:.
AH = 0Fh unmap 4K pages.
CX = first page number.
DX = number of pages<br>
<p><b>Return:</b><br>CF clear
AL = 00h/01h if ???
</PRE>
<p><b>Note:</b>
If CX=0100h and DX=0010h, the HMA is remapped to
simulate a disabled A20
<PRE>
<p>
<a name=table3541></a>
(Table 03541)
Values for calling QEMM QPI function 1000h:.
AX = 1000h get protected-mode interface.
DS:SI -> 16-byte buffer for two GDT entries.
ES:DI -> buffer for 4K page table<br>
<p><b>Return:</b><br>CF clear
EAX = offset of protected-mode API entry point
DS:SI buffer filled with two GDT descriptors
first is QEMM code segment, second is data???
ES:DI buffer filled with 4K page table
DI points to first unused page table entry
</PRE>
<p><b>See Also:</b>
<a href="rb-7492.htm">INT 67/AX=DE01h</a>
<PRE>
<p>
<a name=table3542></a>
(Table 03542)
Values for calling QEMM QPI function 1001h:.
AX = 1001h get CPU debug registers.
ES:DI -> buffer for debug registers (8 DWORDs)<br>
<p><b>Return:</b><br>CF clear
BL = INT01 handling <a href="rb-7414.htm#Table3543">(see #03543)</a>
ES:DI buffer filled
<p>
<a name=table3543></a>
(Table 03543)
Values for calling QEMM QPI function 1002h:
AX = 1002h set CPU debug registers
BL = INT01 handling
00h  reflect all debugging exceptions as V86-mode INT 01's
else convert debugging exceptions other than single-step
into V86-mode INT 03's, single-step to INT 01's
ES:DI -> buffer containing debug registers (8 DWORDs)<br>
<p><b>Return:</b><br>CF clear
</PRE>
<p><b>Notes:</b>
Identical to INT 67/AX=DE09h if BL=01h.
The INT01 handling flag is set to 01h by the general-protection
violation handler for certain privileged instructions
<p><b>See Also:</b>
#03542
<PRE>
<p>
<a name=table3544></a>
(Table 03544)
Values for calling QEMM QPI function 1003h:.
AX = 1003h get machine status word CR0<br>
<p><b>Return:</b><br>CF clear
EAX = contents of CR0
</PRE>
<p><b>See Also:</b>
<a href="rb-7498.htm">INT 67/AX=DE07h</a>
<PRE>
<p>
<a name=table3545></a>
(Table 03545)
Values for calling QEMM QPI function 1004h:.
AX = 1004h allocate a 4K page<br>
<p><b>Return:</b><br>CF clear if successful
EDX = linear address of allocated page
CF set on error
</PRE>
<p><b>See Also:</b>
<a href="rb-7495.htm">INT 67/AX=DE04h</a>
<PRE>
<p>
<a name=table3546></a>
(Table 03546)
Values for calling QEMM QPI function 1005h:.
AX = 1005h free 4K page.
EDX = linear address of page to free<br>
<p><b>Return:</b><br>CF clear
</PRE>
<p><b>See Also:</b>
<a href="rb-7496.htm">INT 67/AX=DE05h</a>
<PRE>
<p>
<a name=table3547></a>
(Table 03547)
Values for calling QEMM QPI function 1006h:.
AX = 1006h NOP<br>
<p><b>Return:</b><br>CF set
<p>
<a name=table3548></a>
(Table 03548)
Values for calling QEMM QPI function 1007h:
AX = 1007h get maximum physical memory address<br>
<p><b>Return:</b><br>CF clear
EDX = physical address of highest 4K memory page
</PRE>
<p><b>See Also:</b>
<a href="rb-7493.htm">INT 67/AX=DE02h</a>
<PRE>
<p>
<a name=table3549></a>
(Table 03549)
Values for calling QEMM QPI function 1008h:.
AX = 1008h get physical address of page in first megabyte.
CX = page number (linear address shifted right 12 bits)<br>
<p><b>Return:</b><br>CF clear
EDX = linear address of page
</PRE>
<p><b>See Also:</b>
#03548 - #03624 - #03625
<PRE>
<p>
<a name=table3550></a>
(Table 03550)
Values for calling QEMM QPI function 1009h:.
AX = 1009h switch to protected mode.
ESI = linear address in first megabyte of system reg values
(see INT 67/AX=DE0Ch).
Interrupts disabled<br>
<p><b>Return:</b><br>Interrupts disabled
GDTR, IDTR, LDTR, TR loaded
SS:ESP must have at least 16 bytes space, and the
entry point is required to set up a new stack
before enabling interrupts
EAX, ESI, DS, ES, FS, GS destroyed
<p>
<a name=table3551></a>
(Table 03551)
Values for calling QEMM QPI function 100Ah:
AX = 100Ah switch back to virtual-86 mode
DS = selector for data segment from function 1000h
SS:ESP in first megabyte of linear memory
interrupts disabled.
<p><b>STACK:</b><br>QWORD  return address from FAR call to 32-bit segment
DWORD  EIP
DWORD  CS
DWORD  reserved for EFLAGS
DWORD  ESP
DWORD  SS
DWORD  ES
DWORD  DS
DWORD  FS
DWORD  GS.
Will switch to virtual86 mode with interrupts disabled, all
segment registers loaded, and EAX destroyed.
<p>
<a name=table3552></a>
(Table 03552)
Values for calling QEMM QPI function 11h:.
AH = 11h get memory type map.
AL = zero/nonzero ??? (set by QEMM.COM but apparently ignored
by QEMM 6.00).
ES:DI -> 256-byte buffer for memory types<br>
<p><b>Return:</b><br>CF clear
BL = ???
ES:DI buffer filled
</PRE>
<p><b>Note:</b>
Each byte of the buffer corresponds to a 4K page, and
<PRE>
<p><b>contains the type of that page:</b><br>00h = mappable,
02h = mapped ROM, 03h = high RAM, 04h = excluded,
05h = video, 06h = ROM, 07h = adapter ROM,
08h = split ROM, 09h = page frame, 0Ah = RAMmable,
0Bh = conventional, 83h = high RAM under MS Windows
<p>
<a name=table3553></a>
(Table 03553)
Values for calling QEMM QPI function 12h:.
AH = 12h get HIRAM chain<br>
<p><b>Return:</b><br>CF clear
BX = segment of first MCB in high memory
0000h if no high memory
<p>
<a name=table3554></a>
(Table 03554)
Values for calling QEMM QPI function 1300h:
AX = 1300h VIDRAMEGA???
BL = 00h copy ???
nonzero copy ??? (reverse)<br>
<p><b>Return:</b><br>CF clear
AL = status
00h if all pages clean
01h if any page dirty
<p>
<a name=table3555></a>
(Table 03555)
Values for calling QEMM QPI function 1301h:
AX = 1301h check if pages modified
DX:DI = start address of range to check
CX = length of range in paragraphs<br>
<p><b>Return:</b><br>CF clear
CX = status
0000h none of the indicated pages is dirty
DI destroyed
1000h one or more pages is dirty
DI = low word of first dirty page's linear addr
<p>
<a name=table3556></a>
(Table 03556)
Values for calling QEMM QPI function 1302h:
AX = 1302h ???
BL = ???
BH = ???
CX = ???
SI = offset of ???
DI = offset of ???
???<br>
<p><b>Return:</b><br>CF clear
???
</PRE>
<p><b>Note:</b>
Disables certain interrupts at the two 8259 PICs during
execution; also modifies CRT controller during
execution under certain circumstances
<PRE>
<p>
<a name=table3557></a>
(Table 03557)
Values for calling QEMM QPI function 1303h:.
AX = 1303h initialize EGA graphics virtualization.
BX = number of pages (less 1) of EMS to allocate<br>
<p><b>Return:</b><br>CF clear if successful
DX = EMS handle
CF set on error
<p>
<a name=table3558></a>
(Table 03558)
Values for calling QEMM QPI function 1304h:
AX = 1304h shutdown EGA graphics virtualization
DX = EMS handle being used for virtualization<br>
<p><b>Return:</b><br>CF clear
<p>
<a name=table3559></a>
(Table 03559)
Values for calling QEMM QPI function 1305h:
AX = 1305h select portion of EGA graphics to virtualize???
(related to graphics virtualization, changes memory mappings)
CX = start offset within A000h segment of virtualized mem???<br>
<p><b>Return:</b><br>CF clear
</PRE>
<p><b>Note:</b>
Disables certain interrupts at the two 8259 PICs during
execution <a href="rb-7414.htm#Table3566">(see #03566)</a> and runs inside a QEMM
critical section
<PRE>
<p>
<a name=table3560></a>
(Table 03560)
Values for calling QEMM QPI function 1306h:.
AX = 1306h set DESQview critical section counter address.
ES:BX -> WORD DESQview critical section counter or 0000h:0000h<br>
<p><b>Return:</b><br>CF clear
</PRE>
<p><b>Note:</b>
Also sets a pointer in the low-memory part of QEMM to
the current value of INT 15 if ES:BX not 0000h:0000h
<PRE>
<p>
<a name=table3561></a>
(Table 03561)
Values for calling QEMM QPI function 1307h:.
AX = 1307h ??? (changes memory mappings for entire A000h segment)<br>
<p><b>Return:</b><br>CF clear
</PRE>
<p><b>Note:</b>
Disables certain interrupts at the two 8259 PICs during
execution <a href="rb-7414.htm#Table3566">(see #03566)</a> and runs inside a QEMM
critical section
<PRE>
<p>
<a name=table3562></a>
(Table 03562)
Values for calling QEMM QPI function 1308h:.
AX = 1308h start/reset CRT controller I/O trapping.
BL = subfunction
00h restore CRTC I/O port trapping to previous state
else start trapping all accesses to I/O ports 03B0-03DF<br>
<p><b>Return:</b><br>CF clear
</PRE>
<p><b>Note:</b>
If called more than once in a row with BL nonzero, the
original state of the I/O port trapping will be lost
<PRE>
<p>
<a name=table3563></a>
(Table 03563)
Values for calling QEMM QPI function 1309h:.
AX = 1309h Hercules mode-change support.
ES:BX -> new address for Hercules mode-change callback<br>
<p><b>Return:</b><br>CF clear
</PRE>
<p><b>Note:</b>
The callback function is called whenever the CRTC mode
register is written, with AL set to the value written
<PRE>
<p>
<a name=table3564></a>
(Table 03564)
Values for calling QEMM QPI function 130Ah:.
AX = 130Ah virtualize EGA/VGA DAC registers (I/O ports 03C8h/03C9h).
CX:DX -> DAC register virtualization buffer <a href="rb-7414.htm#Table3647">(see #03647)</a>
or 0000h:0000h to disable<br>
<p><b>Return:</b><br>CF clear
<p>
<a name=table3565></a>
(Table 03565)
Values for calling QEMM QPI function 130Bh:
AX = 130Bh ???
BL = ??? (??? or 00h)<br>
<p><b>Return:</b><br>CF clear
???
</PRE>
<p><b>Note:</b>
Calls AX=130Eh in some cases
<PRE>
<p>
<a name=table3566></a>
(Table 03566)
Values for calling QEMM QPI function 130Ch:.
AX = 130Ch set interrupts to mask.
BX = interrupts to mask out during AX=1302h,AX=1307h,AX=1308h,
AX=130Dh,AX=1310h (BL = master PIC, BH = slave PIC)<br>
<p><b>Return:</b><br>CF clear
<p>
<a name=table3567></a>
(Table 03567)
Values for calling QEMM QPI function 130Dh:
AX = 130Dh map EGA memory at A0000h
???<br>
<p><b>Return:</b><br>CF clear
</PRE>
<p><b>Note:</b>
Disables certain interrupts at the two 8259 PICs during execution
<a href="rb-7414.htm#Table3566">(see #03566)</a> and runs inside a QEMM critical section.
Calls AX=1307h <a href="rb-7414.htm#Table3561">(see #03561)</a>
<PRE>
<p>
<a name=table3568></a>
(Table 03568)
Values for calling QEMM QPI function 130Eh:.
AX = 130Eh ??? (modifies CRT controller setup).
???<br>
<p><b>Return:</b><br>CF clear
<p>
<a name=table3569></a>
(Table 03569)
Values for calling QEMM QPI function 130Fh:
AX = 130Fh reset ???<br>
<p><b>Return:</b><br>CF clear
<p>
<a name=table3570></a>
(Table 03570)
Values for calling QEMM QPI function 1310h:
AX = 1310h copy modified pages to physical video RAM???
???<br>
<p><b>Return:</b><br>CF clear
</PRE>
<p><b>Note:</b>
Disables certain interrupts at the two 8259 PICs during execution
<a href="rb-7414.htm#Table3566">(see #03566)</a> and runs inside a QEMM critical section.
Also calls AX=130Dh <a href="rb-7414.htm#Table3567">(see #03567)</a>
<PRE>
<p>
<a name=table3571></a>
(Table 03571)
Values for calling QEMM QPI function 1311h:.
AX = 1311h set ???.
BL = zero/nonzero???<br>
<p><b>Return:</b><br>CF clear
</PRE>
<p><b>Note:</b>
Certain operations will be performed with interrupts
(as set by AX=130Ch) enabled rather than disabled if
called with BL nonzero
<PRE>
<p>
<a name=table3572></a>
(Table 03572)
Values for calling QEMM QPI function 1312h:.
AX = 1312h (v6.02) NOP???
</PRE>
<p><b>Note:</b>
Called by DV 2.42, but appears to be a NOP in QEMM 6.02
<PRE>
<p>
<a name=table3573></a>
(Table 03573)
Values for calling QEMM QPI function 1400h:.
AX = 1400h initialize DESQview "protection level" support.
ES:DI -> protection level configuration (at least 24 bytes)
<a href="rb-7414.htm#Table3641">(see #03641)</a>.
BL = highest ??? to return (one less than number of words)<br>
<p><b>Return:</b><br>CF clear
AX = ??? (4204h for v6.00)
</PRE>
<p><b>Note:</b>
QEMM also sets the protected mode INT 02 and INT 06
vectors to alternate handlers in certain cases
<PRE>
<p>
<a name=table3574></a>
(Table 03574)
Values for calling QEMM QPI function 1401h:.
AX = 1401h turn off DESQview protection level support
<p><b>Return:</b><br>CF clear
???
</PRE>
<p><b>Notes:</b>
Clears the DV critical-section flag address set with
function 1306h
QEMM also sets the protected mode INT 02 and INT 06
vectors to the default handlers if they had been
revectored by function 1400h
<PRE>
<p>
<a name=table3575></a>
(Table 03575)
Values for calling QEMM QPI function 1402h:.
AX = 1402h set protection level???
BL = protection level???
00h NOP
01h ???
02h ???
other (03h) ???
ES:DI -> ???
<p><b>Return:</b><br>CF clear
???
Format of Data structure:
Offset  Size    Description
00h    WORD    segment of ??? (X, word at X:0136h set to X)
02h    WORD    segment of ??? (word at X:0124h set to this)
04h    WORD    number of paragraphs of ???
06h  3 WORDs   ??? (copied to X:0000h)
0Ch    WORD    ???
<p>
<a name=table3576></a>
(Table 03576)
Values for calling QEMM QPI function 1403h:.
AX = 1403h add ??? to end of list and ??? (execute func 1406h)
ES:DI -> ??? structure added to end of ??? list
(at least 31 bytes, DWORD at offset 06h used for
storing pointer to next struc, WORD at offset 00h
seems to be a key or index)
<p><b>Return:</b><br>CF clear
<p>
<a name=table3577></a>
(Table 03577)
Values for calling QEMM QPI function 1404h:.
AX = 1404h NOP
<p><b>Return:</b><br>CF clear
<p>
<a name=table3578></a>
(Table 03578)
Values for calling QEMM QPI function 1405h:.
AX = 1405h remove ??? from ??? list
BX = key???
<p><b>Return:</b><br>CF clear
<p>
<a name=table3579></a>
(Table 03579)
Values for calling QEMM QPI function 1406h:.
AX = 1406h ???
???
<p><b>Return:</b><br>CF clear
???
</PRE>
<p><b>Notes:</b>
This function is a NOP unless protection level 2 or 3
is active
when not a NOP, one of the actions is to write-protect
certain memory pages
<PRE>
<p>
<a name=table3580></a>
(Table 03580)
Values for calling QEMM QPI function 1407h:.
AX = 1407h ???
???
<p><b>Return:</b><br>CF clear
???
</PRE>
<p><b>Note:</b>
Same as function 1406h, but only does anything if
protection level 2 is active
<PRE>
<p>
<a name=table3581></a>
(Table 03581)
Values for calling QEMM QPI function 1408h:.
AX = 1408h unprotect???
???
<p><b>Return:</b><br>CF clear
???
<p>
<a name=table3582></a>
(Table 03582)
Values for calling QEMM QPI function 1409h:.
AX = 1409h abort program causing protection violation???
???
<p><b>Return:</b><br>CF clear
???
<p>
<a name=table3583></a>
(Table 03583)
Values for calling QEMM QPI function 140Ah:.
AX = 140Ah set ???
BX = index of ???
<p><b>Return:</b><br>CF clear
???
</PRE>
<p><b>Notes:</b>
No range checking is performed on BX
this function is a NOP unless protection level 3 active
<PRE>
<p>
<a name=table3584></a>
(Table 03584)
Values for calling QEMM QPI function 140Bh:.
AX = 140Bh get ???
BX = index of ???
SI = 0000h
<p><b>Return:</b><br>CF clear
SI = segment of 256-byte buffer??? or 0000h
</PRE>
<p><b>Notes:</b>
No range checking is performed on BX
this function is a NOP unless protection level 3 active
<PRE>
<p>
<a name=table3585></a>
(Table 03585)
Values for calling QEMM QPI function 15h:.
AH = 15h set timer channel 0 virtualization buffer
ES:BX -> WORD buffer for timer channel 0 divisor
0000h:0000h to disable virtualization
<p><b>Return:</b><br>CF clear
<p>
<a name=table3586></a>
(Table 03586)
Values for calling QEMM v5.00+ QPI function 1600h:.
AX = 1600h get memory access status
ES:DI -> 256-byte buffer
<p><b>Return:</b><br>ES:DI buffer filled
</PRE>
<p><b>Note:</b>
Each byte of the buffer indicates the status of a 4K
page (bit 0 set if read, bit 1 set if written)
<PRE>
<p>
<a name=table3587></a>
(Table 03587)
Values for calling QEMM v5.00+ QPI function 1601h:.
AX = 1601h set memory access status
ES:DI -> 256-byte buffer containing access statuses <a href="rb-7414.htm#Table3586">(see #03586)</a>
<p>
<a name=table3588></a>
(Table 03588)
Values for calling QEMM v5.00+ QPI function 17h:.
AH = 17h get memory usage statistics
ES:DI -> 81-byte buffer for memory statistics <a href="rb-7414.htm#Table3645">(see #03645)</a>
<p><b>Return:</b><br>CF clear
<p>
<a name=table3589></a>
(Table 03589)
Values for calling QEMM v5.11+ QPI function 18h:.
AH = 18h check whether conventional memory mapped into address range
ES:BX = starting address
CX = number of 4K pages
<p><b>Return:</b><br>CF clear
AL = 00h one or more pages is remapped
01h all pages in range are conventional memory
(physical address == virtual address)
<p>
<a name=table3590></a>
(Table 03590)
Values for calling QEMM v5.11+ QPI function 19h:.
AH = 19h NOP
<p><b>Return:</b><br>CF set
<p>
<a name=table3591></a>
(Table 03591)
Values for calling QEMM v5.11+ "QPI_UntrappedIORead" function:.
AX = 1A00h get byte from I/O port.
DX = port number<br>
<p><b>Return:</b><br>CF clear
BL = port value
</PRE>
<p><b>Note:</b>
This function was officially documented with the release of QEMM 7.50
<PRE>
<p>
<a name=table3592></a>
(Table 03592)
Values for calling QEMM v5.11+ "QPI_UntrappedIOWrite" function:.
AX = 1A01h send byte to I/O port.
BL = value to send.
DX = port number<br>
<p><b>Return:</b><br>CF clear
</PRE>
<p><b>Note:</b>
This function was officially documented with the release of QEMM 7.50
<PRE>
<p>
<a name=table3593></a>
(Table 03593)
Values for calling QEMM v5.11+ "QPI_UntrappedIOReadIndexed" function:.
AX = 1A02h.
BH = index value to send.
DX = base port number<br>
<p><b>Return:</b><br>CF clear
BL = value read from I/O port (DX+1)
</PRE>
<p><b>Note:</b>
This function was officially documented with the release of QEMM 7.50
<PRE>
<p>
<a name=table3594></a>
(Table 03594)
Values for calling QEMM v5.11+ "QPI_UntrappedIOWriteIndexed" function:.
AX = 1A03h send bytes to two consecutive I/O ports.
BH = value for first I/O port (DX).
BL = value for second I/O port (DX+1).
DX = base port number<br>
<p><b>Return:</b><br>CF clear
</PRE>
<p><b>Note:</b>
This function was officially documented with the release of QEMM 7.50
<PRE>
<p>
<a name=table3595></a>
(Table 03595)
Values for calling QEMM v7.03+ "QPI_UntrappedIO" function:.
AX = 1A04h.
BX = value to write to port.
CX = direction and size
<p><b>bit 2:</b><br>Output instead of input
<p><b>bit 3:</b><br>Word instead of byte.
DX = I/O port to be accessed<br>
<p><b>Return:</b><br>CF clear
BX = value read (if CX indicates read)
</PRE>
<p><b>Note:</b>
This function was officially documented with the release of QEMM 7.50
<PRE>
<p>
<a name=table3596></a>
(Table 03596)
Values for calling QEMM v7.03+ function 1A05h.
AX = 1A05h.
???<br>
<p><b>Return:</b><br>???
<p>
<a name=table3597></a>
(Table 03597)
Values for calling QEMM v7.03+ "QPI_GetIOCallback" function:
AX = 1A06h<br>
<p><b>Return:</b><br>CF clear
ES:DI -> current I/O callback function <a href="rb-7414.htm#Table3599">(see #03599)</a>
</PRE>
<p><b>Note:</b>
This function was officially documented with the release of QEMM 7.50
<PRE>
<p>
<a name=table3598></a>
(Table 03598)
Values for calling QEMM v7.03+ "QPI_SetIOCallback" function:.
AX = 1A07h.
ES:DI -> new I/O callback function <a href="rb-7414.htm#Table3599">(see #03599)</a><br>
<p><b>Return:</b><br>CF clear
</PRE>
<p><b>Note:</b>
This function was officially documented with the release of QEMM 7.50
<PRE>
<p>
<a name=table3599></a>
(Table 03599)
Values QEMM v7.03+ I/O callback function is called with:.
AL/AX = data to/from trapped port.
CL = I/O direction (00h = IN instruction, else OUT instruction).
DX = I/O port address<br>
<p><b>Return:</b><br>CF clear if port handled by callback function
CF set if not handled
all other registers returned to application executing the IN or OUT
instruction (allowing arbitrary changes to port address, data value,
etc.)
</PRE>
<p><b>See Also:</b>
#03597 - #03598
<PRE>
<p>
<a name=table3600></a>
(Table 03600)
Values for calling QEMM v7.03+ "QPI_GetPortTrap" function:.
AX = 1A08h.
DX = I/O port number<br>
<p><b>Return:</b><br>CF clear
BL = trapping state (00h not being trapped, 01h trap installed)
</PRE>
<p><b>Note:</b>
This function was officially documented with the release of QEMM 7.50
<PRE>
<p>
<a name=table3601></a>
(Table 03601)
Values for calling QEMM v7.03+ "QPI_SetPortTrap" function:.
AX = 1A09h.
DX = I/O port number<br>
<p><b>Return:</b><br>CF clear
</PRE>
<p><b>Note:</b>
This function was officially documented with the release of QEMM 7.50
<PRE>
<p>
<a name=table3602></a>
(Table 03602)
Values for calling QEMM v7.03+ "QPI_ClearPortTrap" function:.
AX = 1A0Ah.
DX = I/O port number<br>
<p><b>Return:</b><br>CF clear
</PRE>
<p><b>Note:</b>
This function was officially documented with the release of QEMM 7.50
<PRE>
<p>
<a name=table3603></a>
(Table 03603)
Values for calling QEMM v5.11+ QPI function 1B00h:.
AX = 1B00h get EMM Import Structure address.
ES:DI -> buffer for EMM import data structure <a href="rb-7414.htm#Table3643">(see #03643)</a><br>
<p><b>Return:</b><br>CF set on error
CF clear if successful
</PRE>
<p><b>See Also:</b>
<a href="rb-2848.htm">INT 21/AX=4402h/SF=01h</a>
<PRE>
<p>
<a name=table3604></a>
(Table 03604)
Values for calling QEMM v5.11+ QPI function 1B01h:.
AX = 1B01h disable V86 mode<br>
<p><b>Return:</b><br>CF set on error
(i.e. no Global EMM Import rec. allocated)
CF clear if successful
</PRE>
<p><b>Note:</b>
Shuts down EMS and initializes Global EMM Import record; this function
is invoked from the callback supplied by INT 2F/AX=1605h
<PRE>
<p>
<a name=table3605></a>
(Table 03605)
Values for calling QEMM v5.11+ QPI function 1B02h:.
AX = 1B02h enable V86 mode<br>
<p><b>Return:</b><br>CF set on error
CF clear if successful
</PRE>
<p><b>Note:</b>
Restarts EMS and frees Global EMM Import record; this function is
invoked from the callback supplied by INT 2F/AX=1605h
<PRE>
<p>
<a name=table3606></a>
(Table 03606)
Values for calling QEMM v5.11+ QPI function 1B03h:.
AX = 1B03h MS Windows initializing.
CX = segment from which Windows init broadcast made???.
DX = Windows startup flags.
DI = Windows version number (major in upper byte)<br>
<p><b>Return:</b><br>CF clear if successful
DS:SI -> V86 mode enable/disable callback
<a href="rb-0000.htm#Table0"></a>(see #02634 at INT 2F/AX=1605h)
ES:BX -> startup info structure <a href="rb-0000.htm#Table0"></a>(see #02631 at INT 2F/AX=1605h)
CF set on error (unable to start Windows)
</PRE>
<p><b>See Also:</b>
<a href="rb-4498.htm">INT 2F/AX=1605h</a>
<PRE>
<p>
<a name=table3607></a>
(Table 03607)
Values for calling QEMM v5.11+ QPI function 1B04h:.
AX = 1B04h MS Windows terminating<br>
<p><b>Return:</b><br>CF clear
<p>
<a name=table3608></a>
(Table 03608)
Values for calling QEMM v5.11+ QPI function 1B05h:
AX = 1B05h determine whether program is driver
DS:DX -> ASCIZ filename<br>
<p><b>Return:</b><br>CF clear
AL = status
01h if string ends in ".DRV"
FFh if string ends in "GDI.EXE"
00h otherwise
</PRE>
<p><b>Note:</b>
When MS Windows 3.0 standard mode starts, QEMM patches all drivers
until GDI.EXE is loaded
<PRE>
<p>
<a name=table3609></a>
(Table 03609)
Values for calling QEMM v5.11+ QPI function 1B06h:.
AX = 1B06h patch protected-mode check in Windows driver.
CX = length of data pointed at by DS:DX.
DS:DX -> buffer containing Windows driver code<br>
<p><b>Return:</b><br>CF clear
</PRE>
<p><b>Note:</b>
Patches all SMSW x/TEST x,1 instruction sequences into MOV x,CS/VERW x
sequences, which has the effect that the protected-mode check will
only indicate protected mode in native protected mode and not in V86
mode
<PRE>
<p>
<a name=table3610></a>
(Table 03610)
Values for calling QEMM v5.11+ QPI function 1B07h:.
AX = 1B07h
</PRE>
<p><b>BUG:</b>
QEMM 6.00-7.01 accept this and branch randomly
<PRE>
<p>
<a name=table3611></a>
(Table 03611)
Values for calling QEMM v5.11+ QPI function 1Bxxh:.
AX = 1B08h to 1BFFh<br>
<p><b>Return:</b><br>CF set
<p>
<a name=table3612></a>
(Table 03612)
Values for calling QEMM v5.11+ QPI function 1C00h:
AX = 1C00h disable IRQ0-7 calldowns<br>
<p><b>Return:</b><br>CF clear
<p>
<a name=table3613></a>
(Table 03613)
Values for calling QEMM v5.11+ QPI function 1C01h:
AX = 1C01h set V86-mode IRQ0-7 handlers
ES:DI -> 8 DWORDs containing V86-mode handler addresses<br>
<p><b>Return:</b><br>CF clear
<p>
<a name=table3614></a>
(Table 03614)
Values for calling QEMM v5.11+ QPI function 1C02h:
AX = 1C02h disable IRQ8-15 handlers<br>
<p><b>Return:</b><br>CF clear
<p>
<a name=table3615></a>
(Table 03615)
Values for calling QEMM v5.11+ QPI function 1C03h:
AX = 1C03h set V86-mode IRQ8-15 handlers
ES:DI -> 8 DWORDs containing V86-mode handler addresses
</PRE>
<p><b>BUG:</b>
Although the jump table only contains four entries, QEMM 6.00 will
attempt to use it for any value of AL between 00h and 2Ah, thus
branching unpredictably for AL=04h-2Ah; QEMM v7.01 behaves
similarly for AL=04h-1Bh
<p><b>Note:</b>
When enabled, the appropriate IRQs are reflected back to the specified
handlers in virtual-86 mode after the CPU automatically invokes the
protected-mode handler inside QEMM
<PRE>
<p>
<a name=table3616></a>
(Table 03616)
Values for calling QEMM v7.03+ "QPI_SimulateHWInt" function:.
AX = 1C04h.
BX = number of interrupt to simulate<br>
<p><b>Return:</b><br>???
</PRE>
<p><b>Notes:</b>
This function will allow proper simulation of a hardware interrupt
under DESQview and DESQview/X, where the correct interrupt handler
may be in a different process with a completely different address
space.
This function was officially documented with the release of QEMM v7.50
<PRE>
<p>
<a name=table3617></a>
(Table 03617)
Values for calling QEMM v6.0x only QPI function 1D00h:.
AX = 1D00h switch to pre-Stealth interrupt vector table<br>
<p><b>Return:</b><br>CF clear if supported (QEMM v6.x)
CF set if not supported (QEMM v7+)
</PRE>
<p><b>Notes:</b>
Also switches VGA Save table pointer (0040h:00A8h) and overwrites the
vectors currently assigned for use by the two interrupt controllers
(see INT 67/AX=DE0Ah) with the vectors for INT 08-0F and 70-77 (to
avoid crashing the system)..
Functions 1Dxxh are not supported by QEMM v7.01, and always return CF
set
<PRE>
<p>
<a name=table3618></a>
(Table 03618)
Values for calling QEMM v6.0x only QPI function 1D01h:.
AX = 1D01h restore user interrupt vector table<br>
<p><b>Return:</b><br>CF clear if supported (QEMM v6.x)
CF set if not supported (QEMM v7+)
</PRE>
<p><b>Notes:</b>
Interrupts should be disabled around the AX=1D00h and AX=1D01h calls
because QEMM does not modify the memory maps to map in ROM, so
an interrupt could be disastrous.
Clears any pending IRQ7 at end of function.
Functions 1Dxxh are not supported by QEMM v7.01, and always return CF
set
<PRE>
<p>
<a name=table3619></a>
(Table 03619)
Values for calling QEMM v6.00+ QPI function 1Dxxh:.
AX = 1D02h to 1DFFh<br>
<p><b>Return:</b><br>CF set
<p>
<a name=table3620></a>
(Table 03620)
Values for calling QEMM v6.00+ "QEMM_GET_INFO"/"QPI_GetInfo" function:
AX = 1E00h get Stealth configuration<br>
<p><b>Return:</b><br>CF clear
BL = memory configuration flags (documented as "reserved") <a href="rb-7414.htm#Table3644">(see #03644)</a>
BH = (v7.00+) disk buffer flags
<p><b>bit 0:</b><br>DISKBUFFRAME buffer instead of DISKBUF buffer
<p><b>bit 1:</b><br>Buffer has already been used.
CL = stealth type (00h none, 46h Frame, 4Dh Map, 50h Protect).
CH = suspend/resume interrupt (00h none).
DL = (v7.00+) size of QEMM disk buffer in KB (00h none).
DH = reserved (always 00h for v6.00).
SI = reserved (always 0000h for v6.00).
DI = reserved (always 0000h for v6.00)
</PRE>
<p><b>Note:</b>
This function is officially documented
<PRE>
<p>
<a name=table3621></a>
(Table 03621)
Values for calling QEMM v6.00+ "QPI_GetStealthCount" function:.
AX = 1E01h get number of Stealth'ed ROMs<br>
<p><b>Return:</b><br>CF clear
BX = number of Stealth'ed ROMs
</PRE>
<p><b>Note:</b>
This function is officially documented
<PRE>
<p>
<a name=table3622></a>
(Table 03622)
Values for calling QEMM v6.00+ "QPI_GetStealthList" function:.
AX = 1E02h.
ES:DI -> buffer for Stealth ROM info <a href="rb-7414.htm#Table3646">(see #03646)</a><br>
<p><b>Return:</b><br>CF clear
BX = number of Stealth'ed ROMs
ES:DI buffer filled
</PRE>
<p><b>Note:</b>
This function is officially documented
<PRE>
<p>
<a name=table3623></a>
(Table 03623)
Values for unimplemented Stealth information functions:.
AX = 1E03h to 1EFFh<br>
<p><b>Return:</b><br>CF set
<p>
<p>
<a name=table3624></a>
(Table 03624)
Values for calling QEMM v6.00+ "QEMM_GET_PTE"/"QPI_GetPTE" function:
AX = 1F00h get page table entry
CX = page number (0000h-010Fh)<br>
<p><b>Return:</b><br>CF clear
EDX = page table entry
</PRE>
<p><b>Note:</b>
This function is officially documented
<PRE>
<p>
<a name=table3625></a>
(Table 03625)
Values for calling QEMM v6.00+ "QEMM_SET_PTE"/"QPI_SetPTE" function:.
AX = 1F01h set page table entry.
CX = page number (0000h-010Fh).
EDX = new page table entry<br>
<p><b>Return:</b><br>CF clear
</PRE>
<p><b>Note:</b>
This function is officially documented
<p><b>See Also:</b>
#03549
<PRE>
<p>
<a name=table3626></a>
(Table 03626)
Values for calling QEMM v6.00+ QPI function 1Fxxh:.
AX = 1F02h to 1FFFh<br>
<p><b>Return:</b><br>CF set
<p>
<a name=table3627></a>
(Table 03627)
Values for calling QEMM v6.00+ "QEMM_GET_VHI_INFO"/"QPI_GetVHIInfo" function:
AX = 2000h "QEMM_GET_VHI_INFO" get VirtualHDIRQ information<br>
<p><b>Return:</b><br>CF clear
BL = flags
<p><b>bit 7:</b><br>VirtualHDIRQ setting respected
(set if Stealth active)
bits 6-1 reserved
<p><b>bit 0:</b><br>VirtualHDIRQ currently enabled
(INT 15/AH=90h suppressed when enabled)
</PRE>
<p><b>Note:</b>
This function is officially documented
<p><b>See Also:</b>
#03628
<PRE>
<p>
<a name=table3628></a>
(Table 03628)
Values for calling QEMM v6.00+ "QEMM_SET_VHI_INFO"/"QPI_SetVHIInfo" function:.
AX = 2001h set VirtualHDIRQ state.
BL bit 0 = new VirtualHDIRQ state<br>
<p><b>Return:</b><br>CF clear
BL = old VHI setting (bits 0 and 7, see #03627)
</PRE>
<p><b>Note:</b>
This function is officially documented
<p><b>See Also:</b>
#03627
<PRE>
<p>
<a name=table3629></a>
(Table 03629)
Values for calling QEMM v6.00+ QPI function 20xxh:.
AX = 2002h to 20FFh<br>
<p><b>Return:</b><br>CF set
<p>
<a name=table3630></a>
(Table 03630)
Values for calling QEMM v6.00+ "QEMM_COPY_STEALTH_ROMS"/"QPI_CopyStealthRoms":
AX = 2100h copy data from Stealthed address space
DS:SI -> start address of hidden memory to copy
ES:DI -> buffer for copied data
ECX = number of bytes to copy<br>
<p><b>Return:</b><br>CF clear if successful
CF set on error (no Stealth or DS:SI < C000h:0000h or DS:SI + ECX > 1M)
</PRE>
<p><b>Note:</b>
This function was officially documented with the release of QEMM 7.50
<PRE>
<p>
<a name=table3631></a>
(Table 03631)
Values for calling QEMM v6.00+ QPI function 21xxh:.
AX = 2101h to 21FFh<br>
<p><b>Return:</b><br>CF set
<p>
<a name=table3632></a>
(Table 03632)
Values for calling QEMM v6.03+ QPI function 2200h:
AX = 2200h DESQview/X support -- get ???<br>
<p><b>Return:</b><br>CF clear
ES:DI -> ???
<p>
<a name=table3633></a>
(Table 03633)
Values for calling QEMM v6.03+ QPI function 2201h:
AX = 2201h DESQview/X support -- set ???
ES:DI -> ??? or 0000h:0000h<br>
<p><b>Return:</b><br>CF clear if successful
CF set on error
<p>
<a name=table3634></a>
(Table 03634)
Values for calling QEMM v6.04+ QPI function 2300h:
AX = 2300h get ???
BX = which ??? to get (must be 0000h for v6.04)<br>
<p><b>Return:</b><br>CF clear if successful
ES:DI -> ???
CF set on error
<p>
<a name=table3635></a>
(Table 03635)
Values for calling QEMM v6.04+ QPI function 2301h:
AX = 2301h set ???
BX = which ??? to set (must be 0000h for v6.04)
ES:DI -> ???<br>
<p><b>Return:</b><br>CF clear if successful
CF set on error
<p>
<a name=table3636></a>
(Table 03636)
Values for calling QEMM v6.04+ QPI function 2302h:
AX = 2302h clear specified ???
BX = which ??? to clear (must be 0000h for v6.04)<br>
<p><b>Return:</b><br>CF clear if successful
CF set on error
<p>
<a name=table3637></a>
(Table 03637)
Values for calling QEMM v6.04+ QPI function 23FFh:
AX = 23FFh clear all ???<br>
<p><b>Return:</b><br>CF clear if successful
CF set on error
<p>
<a name=table3638></a>
(Table 03638)
Values for calling QEMM v6.04+ QPI function 23xxh:
AX = 2303h to 23FEh<br>
<p><b>Return:</b><br>CF set
<p>
<a name=table3639></a>
(Table 03639)
Values for calling QEMM v7.01+ QPI function 24h:
AH = 24h ST-DBL support
AL = subfunction
00h set ???
EDX -> information table (EDX = segment SHL 16 + offset)
01h ???<br>
<p><b>Return:</b><br>CF clear if successful
CF set on error
<p>
<a name=table3640></a>
(Table 03640)
Values for calling QEMM unimplemented QPI functions:
AH = 25h to FFh<br>
<p><b>Return:</b><br>CF set
<p>
Format of QEMM protection level configuration:
<a name=table3641></a>
Offset  Size    Description     (Table 03641)
00h    WORD    segment of 128 breakpoint (INT 3) instructions for use in
DESQview protection level 3 interrupt vector checking, or
0000h to disable; in pl3, INTs 00-7F are pointed at these
breakpoints
02h    DWORD   -> array of actual interrupt handler addresses for INT 00-7F
when interrupt vectors are pointed at protection level 3
breakpoints
06h    DWORD   far pointer to ??? region list <a href="rb-7414.htm#Table3642">(see #03642)</a>
0Ah    DWORD   far pointer to buffer for returned ???
0Eh    DWORD   seg:ofs of function to call on protection violation???
12h    WORD    segment of ???
14h    DWORD   far pointer to DWORD containing number of paragraphs of
??? for segment at offset 12h
???
<p>
Format of protection level Region List:
<a name=table3642></a>
Offset  Size    Description     (Table 03642)
00h    WORD    number of PAIRS of pointers to follow
02h 2N DWORDs  start/end seg:ofs addresses of ??? regions
</PRE>
<p><b>Note:</b>
QEMM converts the segmented addresses into linear addresses in place
<PRE>
<p>
Format of EMM Import structure:
<a name=table3643></a>
Offset  Size    Description     (Table 03643)
00h    DWORD   physical address of EMM import struct
04h    BYTE    major version (v6.00 sets to 01h)
05h    BYTE    minor version (v6.00 sets to 00h/0Bh)
</PRE>
<p><b>See Also:</b>
<a href="rb-2848.htm">INT 21/AX=4402h/SF=01h</a>
<PRE>
<p>
Bitfields for memory configuration flags:
<a name=table3644></a>
Bit(s)  Description     (Table 03644)
0      conventional memory sorted
1      conventional memory filled
2      ???
3      ???
4      expanded memory is in use
5      ???
<p>
Format of QEMM 6.0 memory statistics:
<a name=table3645></a>
Offset  Size    Description     (Table 03645)
00h    BYTE    01h if Shadow RAM found, 00h otherwise
01h    DWORD   initial conventional memory in bytes
05h    DWORD   initial extended memory in bytes
09h    DWORD   initial expanded memory in bytes
0Dh    DWORD   initial "top" or "shadow" memory in bytes
11h    DWORD   Unavailable conventional memory in bytes
15h    DWORD   Unavailable extended memory in bytes
19h    DWORD   Unavailable expanded memory in bytes
1Dh    DWORD   Unavailable "top" or "shadow" memory in bytes
Add to offset 49h for Total unavailable top/shadow.
21h    DWORD   QEMM code size in bytes
25h    DWORD   QEMM data size in bytes
29h    DWORD   bytes used for TASKS=
2Dh    DWORD   DMA buffer size
31h    DWORD   bytes used for MAPS=
35h    DWORD   bytes of high RAM
39h    DWORD   bytes used by mapped ROMs
3Dh    DWORD   bytes of conventional memory provided by QEMM
41h    DWORD   bytes of extended memory NOT converted by QEMM (EXT=xxx)
45h    DWORD   bytes of EMS/XMS pool memory provided by QEMM
49h    DWORD   Unavailable "top" or "shadow" memory in bytes
Add to offset 1Dh for Total unavailable top/shadow.
4Dh    DWORD   conventional memory overhead in bytes
(set to 0 by QEMM.COM prior to call)
<p>
Format of Stealth ROM info [array]:
<a name=table3646></a>
Offset  Size    Description     (Table 03646)
00h    WORD    starting segment of ROM
02h    WORD    length of ROM in paragraphs
<p>
Format of QEMM EGA/VGA DAC register virtualization buffer:
<a name=table3647></a>
Offset  Size    Description     (Table 03647)
00h    BYTE    (temp) current color register number
01h    BYTE    (temp) number of bytes written so far for current color reg
02h 768 BYTEs  three bytes per color register
</PRE>
<p>
<b>Category: <a href="cat-024.htm">
Memory Management</a>
- <a href="int-67.htm">
Int 67h</a>
- <a href="alpha-q.htm">
Q</a>
</b><p><p><img src=./gif/rbline.gif width="100%" alt="------"><p>
<table border=1 cellpadding=3 cellspacing=1>
<td>
<a href="rb-7413.htm">
<img src=./gif/lup.gif border=0 alt=Prev></a>
<a href="rb-7415.htm">
<img src=./gif/ldown.gif border=0 alt=Next></a>
<a href="../rbrown.htm">
<img src=./gif/lhome.gif border=0 alt=Ralf Brown Page></a>
<td><a href="int.htm">Interrups</a></td>
<td><a href="cat.htm">Categories</a></td>
<td><a href="alpha.htm">Contents</a></td>
</td></table><p>



</BODY>
</HTML>
